## 索引
索引下推：
1、索引不下推是什么样的流程
2、有什么问题
3、索引下推解决的问题
4、为什么以前没有索引下推

总结：server关注执行计划，函数执行。搜索引擎按照规则取数据。

这是个**非常好的“原理型”问题**，本质在问：

> **索引下推（ICP）为什么是 MySQL 5.6 才出现，而不是一开始就有？**

原因不是一句“当时没想到”，而是**架构、能力、代价、收益**多方面共同决定的。下面我从 **4 个层面**给你讲清楚。

---

## 一、最根本原因：早期 MySQL 的“分层边界非常严格”

### 1️⃣ 早期的 Server 层 vs 存储引擎层

在 MySQL 5.6 之前：

* **Server 层**

    * 负责：SQL 语义、WHERE 条件判断、函数计算
* **存储引擎层**

    * 只负责两件事：

        1. 用索引 **定位记录**
        2. 按主键 **返回行数据**

👉 **存储引擎被设计成“黑盒”**

> Server 层告诉你：
> “给我所有 `zipcode = 431200` 的记录”
> 存储引擎就老老实实给

它 **不关心也不理解**：

```sql
MONTH(birthdate) = 3
```

---

### 2️⃣ 为什么当时要这么“死板”？

这是**刻意的设计选择**：

* MySQL 从一开始就支持 **可插拔存储引擎**
* 希望：

    * Server 层 ≠ InnoDB 专属
    * MyISAM、Memory、NDB 都能用同一套接口

所以：

* Server 层 **不把 SQL 语义压给引擎**
* 引擎只提供最基础的能力（scan / lookup）

👉 **ICP 打破了这种“清晰但粗糙”的分工**

---

## 二、第二个原因：当时“条件判断下推”的收益并不明显

### 1️⃣ 早期 MySQL 的典型使用场景

在 5.6 之前（大概 2008～2012 年）：

* 表数据量普遍：

    * 几万
    * 几十万
* 业务：

    * 中小网站
    * OLTP 规模有限
* 索引设计：

    * 条件简单
    * 函数条件少

👉 **即使多回表一点，性能问题也不突出**

---

### 2️⃣ 回表成本当时没那么“贵”

当年：

* SSD 不普及
* 数据库部署更偏向：

    * 小数据
    * 内存命中率高
* 查询复杂度低

所以：

> “为了一个并不明显的性能瓶颈，
> 去复杂化执行引擎架构，不划算”

---

## 三、第三个原因：索引下推在实现上并不“便宜”

### 1️⃣ ICP 本质上增加了什么复杂度？

要实现索引下推，必须解决：

* Server 层要：

    * 把 **WHERE 条件拆解**
    * 区分：

        * 哪些条件能下推
        * 哪些不能
* 存储引擎要：

    * **理解条件表达式**
    * 执行函数、比较、NULL 判断等
* 两层之间要：

    * 传递条件表达式结构（不是字符串）

👉 这对当时的 handler 接口是一次**破坏式升级**

---

### 2️⃣ 早期引擎能力不统一

MySQL 当时：

* 不只是 InnoDB
* 还有：

    * MyISAM
    * Archive
    * CSV
    * Memory

问题是：

| 引擎      | 能否高效支持 ICP |
| ------- | ---------- |
| InnoDB  | 勉强可以       |
| MyISAM  | 几乎没收益      |
| Memory  | 意义不大       |
| Archive | 很困难        |

👉 统一做 ICP，**实现成本极高**

---

## 四、第四个原因：5.6 之前 MySQL 的优化器本身还不成熟

### 1️⃣ 优化器能力的演进

MySQL 的执行优化是逐步演进的：

| 版本      | 重要优化                    |
| ------- | ----------------------- |
| 5.0     | 基本索引                    |
| 5.1     | 子查询改进                   |
| 5.5     | InnoDB 成为默认             |
| **5.6** | **ICP、Index Merge、MRR** |
| 5.7     | 执行计划稳定性                 |
| 8.0     | CTE / 窗口函数              |

👉 **ICP 是“优化器成熟后的产物”**

---

### 2️⃣ ICP 依赖“更聪明的优化器”

要安全地做 ICP，优化器必须：

* 确保：

    * 语义不变
    * 行可见性正确
* 知道：

    * 哪些条件可以提前判断
    * 哪些必须回表后判断

这些能力：

* 在 5.5 之前 **不可靠**
* 5.6 才达到工程可用水平

---

## 五、从“历史视角”一句话解释

> **不是 5.6 之前不能做索引下推，而是：**
>
> * 架构上刻意保持 Server / Engine 的简单边界
> * 当时业务规模下收益不明显
> * 实现成本高、引擎能力不统一
> * 优化器成熟度不够
>
> **直到 5.6，性能需求 + 技术条件才同时成熟**

---

## 六、面试用一句“高分回答”

> MySQL 5.6 之前没有索引下推，主要是因为早期 MySQL 强调 Server 层和存储引擎层的严格解耦，存储引擎只负责索引定位和数据读取，不参与 SQL 语义判断；同时当时数据规模和查询复杂度较低，回表成本不突出，而索引下推在实现上需要优化器和引擎更高的表达式处理能力，成本较高。随着 InnoDB 成为主流、数据规模扩大以及优化器能力提升，MySQL 5.6 才引入索引下推作为重要性能优化。

如果你愿意，我可以：

* 从 **handler 接口演进** 讲 ICP 怎么加进去的
* 对比 **ICP vs 覆盖索引** 的边界
* 用 **EXPLAIN + 实际执行流程** 带你“跑一遍”
